#!/usr/bin/env python

import os
import logging
import logging.handlers
import argparse
import sys
import time  # this is only being used as part of the example
from ConfigParser import SafeConfigParser # read in config file
import subprocess # for executing other command line programs
import shlex # for spliting strings
import time
from datetime import date


try:
    from Queue import Queue, Empty
except ImportError:
    from queue import Queue, Empty  # python 3.x

ON_POSIX = 'posix' in sys.builtin_module_names


# Deafults
global LOG_FILEPATH
CONF_FILENAME = "/etc/openmqtt/openmqtt.conf"
LOG_FILEPATH = "/var/log/openmqtt"
LOG_LEVEL = logging.INFO  # Could be e.g. "DEBUG" or "WARNING"


# Define and parse command line arguments
parser = argparse.ArgumentParser(description="OpenMQTT - Systems Management Service")
parser.add_argument("-c", "--conf", help="configuration file to read from (default '" + CONF_FILENAME + "')")
parser.add_argument("-l", "--log", help="file to write log to (default '" + LOG_FILEPATH + "')")
#parser.add_argument('--speedtest', action="store_true", default=False)

# If the log file is specified on the command line then override the default
args = parser.parse_args()
if args.conf:
	CONF_FILENAME = args.conf
if args.log:
	LOG_FILEPATH = args.log





#=======================================================================================================================
# CONFIG

#user defined configuration variables
global id, broker, username, i, TIMESTAMP
TIMESTAMP = date.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')
i = 0
id = 0
broker = 'broker.openmqtt.org'
username = 'minion'

# Read in configuration file
configParser = SafeConfigParser()   

try:
    configParser.read(CONF_FILENAME)
except IOError:
    print "Unable to open " + CONF_FILENAME

if configParser.has_section('Global'):
	if configParser.has_option('Global','ID'):
		id = configParser.get('Global','ID')
	if configParser.has_option('Global','broker'):
		broker = configParser.get('Global','broker')
	if configParser.has_option('Global','username'):
		username = configParser.get('Global','username')




#=======================================================================================================================
# LOGGER
global logger

# Configure logging to log to a file, making a new file at midnight and keeping the last 3 day's data
# Give the logger a unique name (good practice)
logger = logging.getLogger(__name__)
# Set the log level to LOG_LEVEL
logger.setLevel(LOG_LEVEL)
# Make a handler that writes to a file, making a new file at midnight and keeping 3 backups
handler = logging.handlers.TimedRotatingFileHandler(LOG_FILEPATH + "/client.log", when="midnight", backupCount=3)
# Format each log message like this
formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')
# Attach the formatter to the handler
handler.setFormatter(formatter)
# Attach the handler to the logger
logger.addHandler(handler)

# Make a class we can use to capture stdout and sterr in the log
class MyLogger(object):
	def __init__(self, logger, level):
		"""Needs a logger and a logger level."""
		self.logger = logger
		self.level = level

	def write(self, message):
		# Only log if there is a message (not just a new line)
		if message.rstrip() != "":
			self.logger.log(self.level, message.rstrip())

	def flush(self):
		pass

# Replace stdout with logging to file at INFO level
sys.stdout = MyLogger(logger, logging.INFO)
# Replace stderr with logging to file at ERROR level
sys.stderr = MyLogger(logger, logging.ERROR)









#=======================================================================================================================
# FUNCTIONALITY

def publish(topic, msg):
	global broker, username, logger
	command_line = "mosquitto_pub -t '/" + username + topic + "' -m '" + msg + "' -h '" + broker + "' -u '" + username + "'"
	logger.info(command_line)
	args = shlex.split(command_line)
	p1 = subprocess.Popen(args, stdout=subprocess.PIPE)
	output = p1.communicate()[0]
	return output
	


# REGISTER WITH THE BROKER NETWORK
def register():
	global i, id, logger, TIMESTAMP
	output = publish("/machines/" + str(id) + "/openmqtt", "{\"status\":\"register loop" + str(i) + "\",\"timestamp\":\"" + TIMESTAMP + "\"}")
	print output
	return;












#=======================================================================================================================


# THIS FUNCTION IS EXECUTED EVERY MINUTE
def every_minute():
	global i
	logger.info("Minute Elapsed")
	#logger.info("The counter is now " + str(i))
	#print "This is a print"
		
	i = i + 1
	return;

# THIS FUNCTION IS EXECUTED EVERY HOUR
def every_hour():
	global i
	if i >= 60: # EVERY HOUR
		logger.info("Hour Elapsed")

		register()

		i = 0
	return;


#=======================================================================================================================
# MAIN DAEMON LOOP

publish("/machines/" + str(id) + "/openmqtt", "{\"status\":\"daemon started\",\"timestamp\":\"" + TIMESTAMP + "\"}")


	
oldepoch = int(time.time()) - 3600
# Loop forever, doing something useful hopefully:
while True:
	epoch = int(time.time()) #get current unix timestamp
	TIMESTAMP = date.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')

	if epoch - oldepoch >= 60: # EVERY MINUTE
		every_hour()
		every_minute()

	oldepoch = epoch
	time.sleep(60)
	

publish("/machines/" + str(id) + "/openmqtt", "{\"status\":\"daemon stopped\",\"timestamp\":\"" + TIMESTAMP + "\"}")




